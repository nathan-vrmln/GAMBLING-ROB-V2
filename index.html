<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>GAMBLING ROB</title>
	<link rel="stylesheet" href="assets/css/style.css" />
</head>
<body>
	<!-- Musique de fond -->
	<audio id="bgm" loop preload="auto">
		<source src="assets/audio/musique.mp3" type="audio/mpeg">
	</audio>
	<!-- Bouton mute musique -->
	<button id="music-toggle" class="music-toggle" title="Couper/Activer la musique">üîä</button>
	<!-- Bouton changement de fond -->
	<button id="bg-toggle" class="bg-toggle" title="Changer le fond d'√©cran">üåÑ</button>
	<!-- Modal d'authentification -->
	<div id="auth-overlay" class="auth-overlay">
		<div class="auth-modal">
			<h2 id="auth-title">Connexion</h2>
			<div id="auth-error" class="auth-error" style="display:none;"></div>
			<form id="auth-form" autocomplete="off">
				<input type="text" id="auth-pseudo" placeholder="Pseudo" required minlength="3" maxlength="20" autocomplete="off" />
				<input type="password" id="auth-password" placeholder="Mot de passe" required minlength="6" autocomplete="new-password" />
				<button type="submit" id="auth-submit">Se connecter</button>
			</form>
			<div class="auth-toggle">
				<span id="auth-toggle-text">Pas de compte ?</span>
				<a href="#" id="auth-toggle-link">Cr√©er un compte</a>
			</div>
		</div>
	</div>

	<!-- Contenu du jeu (cach√© jusqu'√† connexion) -->
	<div id="game-content" style="display:none;">
	<header id="robions-display">Robions : 100</header>
	<div id="player-stats" class="player-stats"></div>
	
	<!-- Menu lat√©ral gauche -->
	<div id="sidebar-toggle" class="sidebar-toggle">
		<span class="arrow">‚ñ∫</span>
	</div>
	<div id="sidebar" class="sidebar">
		<div class="sidebar-content">
			<h3>Modules</h3>
			
			<!-- Module: Ferme √† Robions -->
			<div class="farm-module">
				<h4>Ferme √† Robions</h4>
				<div class="farm-progress-container">
					<div id="farm-progress-bar" class="farm-progress-bar"></div>
					<span id="farm-timer" class="farm-timer">60s</span>
				</div>
				<div class="farm-info">
					<div>Production: <span id="farm-production">1</span> Robions</div>
					<div>Vitesse: <span id="farm-speed">60</span>s</div>
				</div>
				<div class="farm-upgrades">
					<button id="farm-upgrade-production" class="farm-btn">
						<div class="farm-btn-title">üí∞ Production</div>
						<div class="farm-cost"><span id="production-cost">10</span> üí∞</div>
						<div class="farm-level">Niveau <span id="production-level">0</span></div>
					</button>
					<button id="farm-upgrade-speed" class="farm-btn">
						<div class="farm-btn-title">‚ö° Vitesse</div>
						<div class="farm-cost"><span id="speed-cost">10</span> üí∞</div>
						<div class="farm-level">Niveau <span id="speed-level">0</span></div>
					</button>
				</div>
			</div>
			
			<!-- Module: Multiplicateurs -->
			<div class="farm-module">
				<h4>Multiplicateur de Gains</h4>
				<div class="multiplier-info">
					<div>Multiplicateur actuel: <span id="current-multiplier">√ó1.00</span></div>
					<div class="mult-level">Niveau: <span id="multiplier-level">0</span></div>
				</div>
				<button id="upgrade-multiplier" class="mult-upgrade-btn">
					<div class="mult-upgrade-title">‚¨Ü Am√©liorer Multiplicateur</div>
					<div class="mult-upgrade-info">+0.01 par niveau</div>
					<div class="mult-cost"><span id="multiplier-cost">100</span> üí∞</div>
				</button>
			</div>
		</div>
	</div>
	<!-- Bouton Classement (haut droite, avant d√©connexion) -->
	<button id="open-leaderboard-btn" class="leaderboard-btn">üèÜ Classement</button>
	<!-- Bouton D√©connexion (haut droite) -->
	<button id="logout-btn" class="logout-btn">D√©connexion</button>
	<div id="current-username" class="current-username"></div>
	<!-- Bouton Collection (haut gauche) -->
	<button id="open-collection-btn" class="collection-btn">üìö Collection</button>

	<!-- Overlay Classement -->
	<div id="leaderboard-overlay" class="leaderboard-overlay" style="display:none;">
		<div class="leaderboard-modal">
			<div class="leaderboard-header">
				<h2>üèÜ Classement des Joueurs</h2>
				<button id="close-leaderboard-btn" class="close-btn">‚úï</button>
			</div>
			<div id="leaderboard-content" class="leaderboard-content">
				<div class="loading">Chargement...</div>
			</div>
		</div>
	</div>

	<!-- Overlay Collection plein √©cran -->
	<div id="collection-overlay" class="collection-overlay" style="display:none;">
		<div class="collection-header">
			<h2>Collection</h2>
			<button id="close-collection-btn" class="close-btn">‚úï</button>
		</div>
		<div id="collection-content" class="collection-content"></div>
	</div>
	<main id="slot-machine-wrapper">
		<div id="slot-machine"></div>
		<div id="gain-summary"></div>
	</main>
	<div id="bet-control">
		<button id="bet-minus" onclick="window.GameLogic.decreaseBet()">‚àí</button>
		<div id="bet-amount">
			<span id="bet-value">0</span>
			<span id="bet-info-icon" title="Info">‚ìò</span>
		</div>
		<button id="bet-plus" onclick="window.GameLogic.increaseBet()">+</button>
		<div id="bet-info-tooltip" style="display:none;">
			<strong>Syst√®me de Mise</strong><br>
			<small>50% chance : <span style="color:#00ff88">+50% √† +150%</span> du gain</small><br>
			<small>50% chance : <span style="color:#ff3366">-30% √† -70%</span> du gain</small><br>
			<small style="color:#888">Mise d√©duite avant le spin ‚Äî si bonus: rembours√©e</small>
		</div>
	</div>
	<button id="spin-button" onclick="window.GameLogic.handleSpin()">SPIN</button>
	<button id="all-in-button" onclick="window.GameLogic.allIn()">ALL IN</button>
	</div><!-- fin game-content -->

	<!-- Scripts dans l'ordre demand√© -->
	<script type="module">
		import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
		import { getFirestore, collection, doc, getDoc, setDoc, query, where, getDocs } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

		// Configuration Firebase
		const firebaseConfig = {
			apiKey: "AIzaSyBHkZktYCmi0b5-K969AiMzCIQgh24Wk78",
			authDomain: "gambling-made.firebaseapp.com",
			projectId: "gambling-made",
			storageBucket: "gambling-made.firebasestorage.app",
			messagingSenderId: "299925832328",
			appId: "1:299925832328:web:6943a73f3ed7ef0ded553d"
		};

		const app = initializeApp(firebaseConfig);
		const db = getFirestore(app);
		window.firebaseDB = db;

		// D√©marrer la musique de fond
		const bgm = document.getElementById('bgm');
		if (bgm) {
			bgm.volume = 0.3;
			// Tenter de d√©marrer (peut √™tre bloqu√©, on r√©essayera au premier clic)
			bgm.play().catch(() => {
				// Si autoplay bloqu√©, d√©marrer au premier clic utilisateur
				const startBgm = () => {
					bgm.play().catch(()=>{});
					document.removeEventListener('click', startBgm);
				};
				document.addEventListener('click', startBgm, { once: true });
			});
		}

		// Gestion du bouton mute musique
		const musicToggle = document.getElementById('music-toggle');
		if (musicToggle && bgm) {
			musicToggle.addEventListener('click', () => {
				if (bgm.muted) {
					bgm.muted = false;
					musicToggle.textContent = 'üîä';
					musicToggle.classList.remove('muted');
				} else {
					bgm.muted = true;
					musicToggle.textContent = 'üîá';
					musicToggle.classList.add('muted');
				}
			});
		}

		// Gestion du changement de fond d'√©cran
		const storedBg = localStorage.getItem('currentBg');
		let currentBg = storedBg === null ? 0 : (parseInt(storedBg, 10) || 0);
		if (storedBg === null) {
			try { localStorage.setItem('currentBg', '0'); } catch(e) {}
		}
		const bgToggle = document.getElementById('bg-toggle');
		// D√©tecter les fonds disponibles (0 = d√©faut, puis 1.jpg, 2.jpg, etc.)
		const availableBgs = [0]; // fond 0 toujours dispo
		
		// D√©tecter les fonds disponibles sans fetch (compatible file://)
		const detectBgs = () => {
			const foundBgs = new Map();
			const detectOne = (i) => new Promise(resolve => {
				const extensions = ['jpg', 'jpeg', 'png'];
				let remaining = extensions.length;
				let resolved = false;
				extensions.forEach(ext => {
					const img = new Image();
					img.onload = () => {
						if (!resolved) {
							resolved = true;
							resolve({ num: i, ext });
						}
					};
					img.onerror = () => {
						remaining--;
						if (remaining === 0 && !resolved) resolve(null);
					};
					img.src = `assets/fonds/${i}.${ext}?t=${Date.now()}`;
				});
			});
			const tasks = [];
			for (let i = 1; i <= 20; i++) tasks.push(detectOne(i));
			Promise.all(tasks).then(results => {
				results.forEach(r => { if (r && !foundBgs.has(r.num)) foundBgs.set(r.num, r.ext); });
				foundBgs.forEach((ext, num) => availableBgs.push(num));
				window.bgExtensions = foundBgs;
				console.log('Fonds disponibles:', availableBgs, 'Extensions:', Object.fromEntries(foundBgs));
				applyBackground(currentBg);
			});
		};
		
		const applyBackground = (bgIndex) => {
			console.log('Application du fond:', bgIndex);
			if (bgIndex === 0) {
				document.body.classList.remove('bg-image');
				document.body.style.backgroundImage = '';
			} else {
				const ext = window.bgExtensions?.get(bgIndex) || 'jpg';
				document.body.classList.add('bg-image');
				document.body.style.backgroundImage = `url('assets/fonds/${bgIndex}.${ext}?t=${Date.now()}')`;
				console.log('Image charg√©e:', `assets/fonds/${bgIndex}.${ext}`);
			}
		};
		
		if (bgToggle) {
			bgToggle.addEventListener('click', () => {
				const currentIndex = availableBgs.indexOf(currentBg);
				const nextIndex = (currentIndex + 1) % availableBgs.length;
				currentBg = availableBgs[nextIndex];
				console.log('Changement de fond:', currentBg, 'Disponibles:', availableBgs);
				localStorage.setItem('currentBg', currentBg);
				applyBackground(currentBg);
			});
		}
		
		detectBgs();


		let isRegisterMode = false;
		let isSubmitting = false;

		// D√©sactiv√©: auto-connexion depuis localStorage (l'utilisateur doit se connecter manuellement)
		const AUTO_LOGIN = false;
		if (AUTO_LOGIN) {
			const currentUser = localStorage.getItem('currentUserPseudo');
			if (currentUser) {
				getDoc(doc(db, 'users', currentUser)).then(docSnap => {
					if (docSnap.exists()) {
						loadUserData(docSnap.data(), currentUser);
					} else {
						localStorage.removeItem('currentUserPseudo');
					}
				}).catch(() => localStorage.removeItem('currentUserPseudo'));
			}
		}

		// Fonction de chargement des donn√©es utilisateur
		function loadUserData(userData, pseudo) {
			window.currentUserPseudo = pseudo;
			window.userRobions = userData.robions || 0;
			window.userUnlockedCards = userData.unlockedCards || [];
			window.farmSpeedLevel = userData.farmSpeedLevel || 0;
			window.farmProductionLevel = userData.farmProductionLevel || 0;
			window.farmProgress = userData.farmProgress || 0;
			window.userMultiplierLevel = userData.multiplierLevel || 0;
			window.userRobcoinBalance = userData.robcoinBalance || 0;
			// D√©clencher une synchronisation forc√©e au premier spin apr√®s connexion
			window.forceSyncPending = true;
			document.getElementById('auth-overlay').style.display = 'none';
			document.getElementById('game-content').style.display = 'block';
			document.getElementById('current-username').textContent = pseudo;
			if (window.initModules) window.initModules();
			if (window.initGameWithUserData) window.initGameWithUserData();
		}

		// Gestion du toggle connexion/inscription
		document.getElementById('auth-toggle-link').addEventListener('click', (e) => {
			e.preventDefault();
			isRegisterMode = !isRegisterMode;
			if (isRegisterMode) {
				document.getElementById('auth-title').textContent = 'Cr√©er un compte';
				document.getElementById('auth-submit').textContent = "S'inscrire";
				document.getElementById('auth-toggle-text').textContent = 'D√©j√† un compte ?';
				document.getElementById('auth-toggle-link').textContent = 'Se connecter';
			} else {
				document.getElementById('auth-title').textContent = 'Connexion';
				document.getElementById('auth-submit').textContent = 'Se connecter';
				document.getElementById('auth-toggle-text').textContent = 'Pas de compte ?';
				document.getElementById('auth-toggle-link').textContent = 'Cr√©er un compte';
			}
			document.getElementById('auth-error').style.display = 'none';
		});

		// Gestion du formulaire connexion/inscription
		document.getElementById('auth-form').addEventListener('submit', async (e) => {
			e.preventDefault();
			if (isSubmitting) return;
			isSubmitting = true;

			const pseudo = document.getElementById('auth-pseudo').value.trim().toLowerCase();
			const password = document.getElementById('auth-password').value;
			const errorEl = document.getElementById('auth-error');

			try {
				if (isRegisterMode) {
					const userDoc = await getDoc(doc(db, 'users', pseudo));
					if (userDoc.exists()) throw new Error('Ce pseudo est d√©j√† utilis√©');
					if (pseudo.length < 3 || pseudo.length > 20) throw new Error('Le pseudo doit contenir entre 3 et 20 caract√®res');
					if (password.length < 6) throw new Error('Le mot de passe doit contenir au moins 6 caract√®res');
					
						await setDoc(doc(db, 'users', pseudo), {
						pseudo, password, robions: 0, unlockedCards: [],
						farmSpeedLevel: 0, farmProductionLevel: 0, farmProgress: 0,
						multiplierLevel: 0, robcoinBalance: 0,
						createdAt: new Date().toISOString()
					});
					localStorage.setItem('currentUserPseudo', pseudo);
					loadUserData({ robions: 0, unlockedCards: [], farmSpeedLevel: 0, farmProductionLevel: 0, farmProgress: 0, multiplierLevel: 0, robcoinBalance: 0 }, pseudo);
				} else {
					const userDoc = await getDoc(doc(db, 'users', pseudo));
					if (!userDoc.exists()) throw new Error('Pseudo ou mot de passe incorrect');
					const userData = userDoc.data();
					if (userData.password !== password) throw new Error('Pseudo ou mot de passe incorrect');
					
					localStorage.setItem('currentUserPseudo', pseudo);
					loadUserData(userData, pseudo);
				}
			} catch (error) {
				errorEl.textContent = error.message;
				errorEl.style.display = 'block';
			} finally {
				isSubmitting = false;
			}
		});

		// Gestion du bouton de d√©connexion
		document.getElementById('logout-btn').addEventListener('click', () => {
			if (confirm('Voulez-vous vraiment vous d√©connecter ?')) {
				localStorage.removeItem('currentUserPseudo');
				window.currentUserPseudo = null;
				window.userRobions = null;
				window.userUnlockedCards = null;
				document.getElementById('auth-overlay').style.display = 'flex';
				document.getElementById('game-content').style.display = 'none';
				document.getElementById('current-username').textContent = '';
				// R√©initialiser le formulaire
				document.getElementById('auth-form').reset();
				document.getElementById('auth-error').style.display = 'none';
			}
		});

		// Gestion du classement
		const leaderboardBtn = document.getElementById('open-leaderboard-btn');
		const leaderboardOverlay = document.getElementById('leaderboard-overlay');
		const closeLeaderboardBtn = document.getElementById('close-leaderboard-btn');

		leaderboardBtn.addEventListener('click', async () => {
			leaderboardOverlay.style.display = 'flex';
			const content = document.getElementById('leaderboard-content');
			content.innerHTML = '<div class="loading">Chargement...</div>';

			try {
				const { collection, getDocs, query, orderBy, limit } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
				const usersRef = collection(db, 'users');
				const q = query(usersRef, orderBy('robions', 'desc'), limit(50));
				const snapshot = await getDocs(q);

				if (snapshot.empty) {
					content.innerHTML = '<div class="no-data">Aucun joueur trouv√©</div>';
					return;
				}

				let html = '<table class="leaderboard-table"><thead><tr><th>#</th><th>Pseudo</th><th>Robions</th><th>Cartes</th></tr></thead><tbody>';
				let rank = 1;
				let currentUserRank = null;
				snapshot.forEach((doc) => {
					const data = doc.data();
					const isCurrentUser = doc.id === window.currentUserPseudo;
					if (isCurrentUser) currentUserRank = rank;
					let rowClass = isCurrentUser ? 'current-user' : '';
					if (rank === 1) rowClass += ' first-place';
					const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank;
					const robions = (data.robions || 0).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
					html += `<tr class="${rowClass.trim()}"><td>${medal}</td><td>${data.pseudo || doc.id}</td><td>${robions}</td><td>${(data.unlockedCards || []).length}</td></tr>`;
					rank++;
				});
				html += '</tbody></table>';
				content.innerHTML = html;
				
				// Mettre √† jour les stats du joueur
				if (window.updatePlayerStats) {
					window.updatePlayerStats(currentUserRank);
				}
			} catch (error) {
				console.error('Erreur chargement classement:', error);
				content.innerHTML = '<div class="error">Erreur de chargement</div>';
			}
		});

		closeLeaderboardBtn.addEventListener('click', () => {
			leaderboardOverlay.style.display = 'none';
		});

		// Fermer en cliquant en dehors de la modal
		leaderboardOverlay.addEventListener('click', (e) => {
			if (e.target === leaderboardOverlay) {
				leaderboardOverlay.style.display = 'none';
			}
		});

		// Sidebar Toggle
		const sidebar = document.getElementById('sidebar');
		const sidebarToggle = document.getElementById('sidebar-toggle');
		
		sidebarToggle.addEventListener('click', () => {
			sidebar.classList.toggle('open');
			sidebarToggle.classList.toggle('open');
		});

		// Fonction d'initialisation des modules
		function initModules() {
			// === FARM MODULE (SIMPLIFI√â) ===
			let farmSpeedLevel = window.farmSpeedLevel || 0;
			let farmProductionLevel = window.farmProductionLevel || 0;
			let farmInterval = null;
			let farmStartTime = 0;
			
			window.farmSpeedLevel = farmSpeedLevel;
			window.farmProductionLevel = farmProductionLevel;
			
			const FARM_BASE_TIME = 60000, FARM_MIN_TIME = 1000, FARM_MAX_PRODUCTION = 50, FARM_BASE_COST = 10;
			
			const getFarmTime = () => Math.max(FARM_MIN_TIME, FARM_BASE_TIME * Math.pow(0.95, farmSpeedLevel));
			const getFarmProduction = () => Math.min(FARM_MAX_PRODUCTION, 1 + farmProductionLevel);
			const getUpgradeCost = (level) => Math.floor(FARM_BASE_COST * Math.pow(1.3, level));
			const getRobions = () => window.robions ?? robions ?? 0;
			const setRobions = (value) => { if (window.robions !== undefined) window.robions = value; else robions = value; };
			const isFarmActive = () => (farmSpeedLevel > 0 || farmProductionLevel > 0) && !!window.hasDoneFirstSpin;
			
			function showRobionsGain(amount) {
				const gainEl = document.createElement('div');
				gainEl.className = 'robions-gain';
				gainEl.textContent = `+${amount} üí∞`;
				document.body.appendChild(gainEl);
				setTimeout(() => gainEl.remove(), 2000);
			}
			
			function updateFarmDisplay() {
				const timeSeconds = (getFarmTime() / 1000).toFixed(1);
				document.getElementById('farm-production').textContent = getFarmProduction();
				document.getElementById('farm-speed').textContent = isFarmActive() ? timeSeconds : '--';
				document.getElementById('speed-cost').textContent = getUpgradeCost(farmSpeedLevel);
				document.getElementById('production-cost').textContent = getUpgradeCost(farmProductionLevel);
				document.getElementById('speed-level').textContent = farmSpeedLevel;
				document.getElementById('production-level').textContent = farmProductionLevel;
				
				const currentRobions = getRobions();
				document.getElementById('farm-upgrade-speed').disabled = currentRobions < getUpgradeCost(farmSpeedLevel) || getFarmTime() <= FARM_MIN_TIME;
				document.getElementById('farm-upgrade-production').disabled = currentRobions < getUpgradeCost(farmProductionLevel) || getFarmProduction() >= FARM_MAX_PRODUCTION;
			}
			
			window.updateFarmDisplay = updateFarmDisplay;
			
			function stopFarmProgress() {
				if (farmInterval) {
					clearInterval(farmInterval);
					farmInterval = null;
				}
				farmStartTime = 0;
			}
			
			function startFarmProgress() {
				stopFarmProgress();
				
				// Si la ferme est inactive, r√©initialiser l'UI et ne rien lancer
				if (!isFarmActive()) {
					const progressBar = document.getElementById('farm-progress-bar');
					const timerDisplay = document.getElementById('farm-timer');
					if (progressBar) progressBar.style.width = '0%';
					if (timerDisplay) timerDisplay.textContent = '--';
					return;
				}

				// D√©marrer un nouveau cycle √† 0
				farmStartTime = Date.now();
				const farmTime = getFarmTime();
				
				farmInterval = setInterval(() => {
					const elapsed = Date.now() - farmStartTime;
					const progress = Math.min(elapsed / farmTime, 1);
					
					const progressBar = document.getElementById('farm-progress-bar');
					const timerDisplay = document.getElementById('farm-timer');
					if (progressBar) progressBar.style.width = (progress * 100) + '%';
					const remaining = Math.max(0, farmTime - elapsed);
					if (timerDisplay) timerDisplay.textContent = Math.ceil(remaining / 1000) + 's';
					
					if (progress >= 1) {
						const production = getFarmProduction();
						setRobions(getRobions() + production);
						showRobionsGain(production);
						if (window.updateRobionsDisplay) window.updateRobionsDisplay();
						if (window.saveGameData) window.saveGameData();
						// Relancer un nouveau cycle
						startFarmProgress();
					}
				}, 100);
			}
			
			document.getElementById('farm-upgrade-speed').addEventListener('click', () => {
				const cost = getUpgradeCost(farmSpeedLevel);
				if (getRobions() >= cost && getFarmTime() > FARM_MIN_TIME) {
					setRobions(getRobions() - cost);
					farmSpeedLevel++;
					window.farmSpeedLevel = farmSpeedLevel;
					if (window.updateRobionsDisplay) window.updateRobionsDisplay();
					if (window.saveGameData) window.saveGameData();
					updateFarmDisplay();
					// Relancer la ferme √† z√©ro apr√®s am√©lioration
					startFarmProgress();
				}
			});
			
			document.getElementById('farm-upgrade-production').addEventListener('click', () => {
				const cost = getUpgradeCost(farmProductionLevel);
				if (getRobions() >= cost && getFarmProduction() < FARM_MAX_PRODUCTION) {
					setRobions(getRobions() - cost);
					farmProductionLevel++;
					window.farmProductionLevel = farmProductionLevel;
					if (window.updateRobionsDisplay) window.updateRobionsDisplay();
					if (window.saveGameData) window.saveGameData();
					updateFarmDisplay();
					// Relancer la ferme √† z√©ro apr√®s am√©lioration
					startFarmProgress();
				}
			});
			
			// Hook pour reset lors du rechargement utilisateur
			window.resetFarmStateOnUserReload = function() {
				stopFarmProgress();
				farmSpeedLevel = window.farmSpeedLevel || 0;
				farmProductionLevel = window.farmProductionLevel || 0;
				updateFarmDisplay();
				startFarmProgress();
			};
			
			// Fonction pour d√©marrer la ferme apr√®s le premier spin
			window.startFarmAfterFirstSpin = function() {
				updateFarmDisplay();
				startFarmProgress();
			};
			
			// Initialisation au chargement
			setTimeout(() => {
				updateFarmDisplay();
				startFarmProgress();
			}, 500);
			
			// === MULTIPLIER MODULE ===
			let multiplierLevel = window.userMultiplierLevel || 0;
			let currentMultiplier = 1 + (multiplierLevel * 0.01);
			window.multiplierLevel = multiplierLevel;
			window.currentMultiplier = currentMultiplier;
			
			const MULTIPLIER_BASE_COST = 100;
			const getMultiplierCost = (level) => Math.floor(MULTIPLIER_BASE_COST * Math.pow(1.15, level));
			
			function updateMultiplierDisplay() {
				document.getElementById('current-multiplier').textContent = '√ó' + currentMultiplier.toFixed(2);
				document.getElementById('multiplier-level').textContent = multiplierLevel;
				document.getElementById('multiplier-cost').textContent = getMultiplierCost(multiplierLevel);
				document.getElementById('upgrade-multiplier').disabled = getRobions() < getMultiplierCost(multiplierLevel);
			}
			
			window.updateMultiplierDisplay = updateMultiplierDisplay;
			
			document.getElementById('upgrade-multiplier').addEventListener('click', () => {
				const cost = getMultiplierCost(multiplierLevel);
				if (getRobions() >= cost) {
					setRobions(getRobions() - cost);
					multiplierLevel++;
					currentMultiplier = 1 + (multiplierLevel * 0.01);
					window.multiplierLevel = multiplierLevel;
					window.currentMultiplier = currentMultiplier;
					if (window.updateRobionsDisplay) window.updateRobionsDisplay();
					if (window.saveGameData) window.saveGameData();
					updateMultiplierDisplay();
				}
			});
			
			updateMultiplierDisplay();
			
			// === ROBCOIN MARKET MODULE ===
			let robcoinBalance = window.userRobcoinBalance || 0;
			let robcoinPrice = 10;
			let lastPrice = robcoinPrice;
			window.robcoinBalance = robcoinBalance;
			
			function updateRobcoinPrice() {
				const change = (Math.random() - 0.5) * 0.16;
				lastPrice = robcoinPrice;
				robcoinPrice = Math.max(1, robcoinPrice * (1 + change) + (10 - robcoinPrice) * 0.05);
				updateMarketDisplay();
			}
			
			function updateMarketDisplay() {
				document.getElementById('robcoin-price').textContent = robcoinPrice.toFixed(2) + ' üí∞';
				const percentChange = ((robcoinPrice - lastPrice) / lastPrice * 100);
				const changeEl = document.getElementById('price-change');
				changeEl.textContent = (percentChange >= 0 ? '+' : '') + percentChange.toFixed(2) + '%';
				changeEl.className = 'price-change ' + (percentChange >= 0 ? 'positive' : 'negative');
				document.getElementById('robcoin-balance').textContent = robcoinBalance.toFixed(2);
				document.getElementById('holdings-value').textContent = (robcoinBalance * robcoinPrice).toFixed(0);
				
				const amount = parseFloat(document.getElementById('robcoin-amount').value) || 1;
				const buyCost = Math.ceil(amount * robcoinPrice);
				const sellGain = Math.floor(amount * robcoinPrice);
				document.getElementById('buy-cost').textContent = buyCost + ' üí∞';
				document.getElementById('sell-gain').textContent = sellGain + ' üí∞';
				document.getElementById('buy-robcoin').disabled = getRobions() < buyCost || amount <= 0;
				document.getElementById('sell-robcoin').disabled = robcoinBalance < amount || amount <= 0;
			}
			
			document.getElementById('buy-robcoin').addEventListener('click', () => {
				const amount = parseFloat(document.getElementById('robcoin-amount').value) || 1;
				const cost = Math.ceil(amount * robcoinPrice);
				if (getRobions() >= cost && amount > 0) {
					setRobions(getRobions() - cost);
					robcoinBalance += amount;
					window.robcoinBalance = robcoinBalance;
					if (window.updateRobionsDisplay) window.updateRobionsDisplay();
					if (window.saveGameData) window.saveGameData();
					updateMarketDisplay();
				}
			});
			
			document.getElementById('sell-robcoin').addEventListener('click', () => {
				const amount = parseFloat(document.getElementById('robcoin-amount').value) || 1;
				const gain = Math.floor(amount * robcoinPrice);
				if (robcoinBalance >= amount && amount > 0) {
					setRobions(getRobions() + gain);
					robcoinBalance -= amount;
					window.robcoinBalance = robcoinBalance;
					if (window.updateRobionsDisplay) window.updateRobionsDisplay();
					if (window.saveGameData) window.saveGameData();
					updateMarketDisplay();
				}
			});
			
			document.getElementById('robcoin-amount').addEventListener('input', updateMarketDisplay);
			setInterval(updateRobcoinPrice, 8000);
			updateMarketDisplay();
		}
		
		window.initModules = initModules;
	</script>
	<script src="assets/js/slotmachine.js"></script>
	<script src="assets/js/game.js"></script>
	<script src="assets/js/ui.js"></script>
</body>
</html>

