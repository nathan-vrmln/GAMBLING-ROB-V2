<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>GAMBLING ROBgit commit -m "Initial commit"</title>
	<link rel="stylesheet" href="assets/css/style.css" />
</head>
<body>
	<!-- Musique de fond -->
	<audio id="bgm" loop preload="auto">
		<source src="assets/audio/musique.mp3" type="audio/mpeg">
	</audio>
	<!-- Bouton mute musique -->
	<button id="music-toggle" class="music-toggle" title="Couper/Activer la musique">üîä</button>
	<!-- Bouton changement de fond -->
	<button id="bg-toggle" class="bg-toggle" title="Changer le fond d'√©cran">üåÑ</button>
	<!-- Modal d'authentification -->
	<div id="auth-overlay" class="auth-overlay">
		<div class="auth-modal">
			<div id="auth-error" class="auth-error" style="display:none;"></div>
			<form id="auth-form" autocomplete="off">
				<input type="text" id="auth-pseudo" placeholder="Pseudo" required minlength="3" maxlength="20" autocomplete="off" />
				<input type="password" id="auth-password" placeholder="Mot de passe" required minlength="6" autocomplete="new-password" />
				<button type="submit" id="auth-submit">Se connecter</button>
			</form>
			<div class="auth-toggle">
				<span id="auth-toggle-text">Pas de compte ?</span>
				<a href="#" id="auth-toggle-link">Cr√©er un compte</a>
			</div>
		</div>
	</div>

	<!-- Contenu du jeu (cach√© jusqu'√† connexion) -->
	<div id="game-content" style="display:none;">
	<header id="robions-display"><span class="robions-text">100</span><img src="assets/images/robion.png" alt="Robion" class="robion-logo"></header>
	<div id="last-result" style="display:none;"></div>
	<div id="player-stats" class="player-stats"></div>
	
	<!-- Menu lat√©ral gauche -->
	<div id="sidebar-toggle" class="sidebar-toggle">
		<span class="arrow">‚ñ∫</span>
	</div>
	<div id="sidebar" class="sidebar">
		<div class="sidebar-content">
			<h3>Modules</h3>
			
			<!-- Module: Ferme √† Robions -->
			<div class="farm-module">
				<h4>Ferme √† Robions</h4>
				<div class="farm-progress-container">
					<div id="farm-progress-bar" class="farm-progress-bar"></div>
					<span id="farm-timer" class="farm-timer">60s</span>
				</div>
				<div class="farm-info">
					<div>Production: <span id="farm-production">1</span> Robions</div>
					<div>Vitesse: <span id="farm-speed">60</span>s</div>
				</div>
				<div class="farm-upgrades">
					<button id="farm-upgrade-production" class="farm-btn">
						<div class="farm-btn-title">üí∞ Production</div>
						<div class="farm-cost"><span id="production-cost">10</span> üí∞</div>
						<div class="farm-level">Niveau <span id="production-level">0</span></div>
					</button>
					<button id="farm-upgrade-speed" class="farm-btn">
						<div class="farm-btn-title">‚ö° Vitesse</div>
						<div class="farm-cost"><span id="speed-cost">10</span> üí∞</div>
						<div class="farm-level">Niveau <span id="speed-level">0</span></div>
					</button>
				</div>
			</div>
			
			<!-- Module: Multiplicateurs -->
			<div class="farm-module">
				<h4>Multiplicateur de Gains</h4>
				<div class="multiplier-info">
					<div>Multiplicateur actuel: <span id="current-multiplier">√ó1.00</span></div>
					<div class="mult-level">Niveau: <span id="multiplier-level">0</span></div>
				</div>
				<button id="upgrade-multiplier" class="mult-upgrade-btn">
					<div class="mult-upgrade-title">‚¨Ü Am√©liorer Multiplicateur</div>
					<div class="mult-upgrade-info">+0.01 par niveau</div>
					<div class="mult-cost"><span id="multiplier-cost">100</span> üí∞</div>
				</button>
			</div>
		</div>
	</div>
	<!-- Bouton Classement (haut droite, avant d√©connexion) -->
	<button id="open-leaderboard-btn" class="leaderboard-btn">üèÜ Classement</button>
	<!-- Boutons Sauvegarde et D√©connexion (haut droite) -->
	<button id="save-btn" class="save-btn">üíæ Sauver</button>
	<button id="logout-btn" class="logout-btn">D√©connexion</button>
	<div id="current-username" class="current-username"></div>
	<!-- Bouton Collection (haut gauche) -->
	<button id="open-collection-btn" class="collection-btn">üìö Collection</button>

	<!-- Menu boutique (droite) -->
	<div id="shop-toggle" class="shop-toggle">
		<span class="arrow">‚óÑ</span>
	</div>
	<div id="shop-sidebar" class="shop-sidebar">
		<div class="shop-content">
			<h3>üõí Boutique</h3>
			<div class="farm-module">
				<h4>Boutique en construction...</h4>
				<p style="color: #aaa; text-align: center; font-size: 14px;">Bient√¥t disponible !</p>
			</div>
		</div>
	</div>

	<!-- Overlay Classement -->
	<div id="leaderboard-overlay" class="leaderboard-overlay" style="display:none;">
		<div class="leaderboard-modal">
			<div class="leaderboard-header">
				<h2>üèÜ Classement des Joueurs</h2>
				<button id="close-leaderboard-btn" class="close-btn">‚úï</button>
			</div>
			<div id="leaderboard-content" class="leaderboard-content">
				<div class="loading">Chargement...</div>
			</div>
		</div>
	</div>

	<div id="collection-overlay" class="collection-overlay" style="display:none;">
		<div class="collection-header">
			<h2>Collection</h2>
			<div style="display:flex; gap:10px; align-items:center;">
				<label style="display:flex; gap:8px; align-items:center; cursor:pointer;">
					<input type="checkbox" id="collection-family-toggle" style="width:18px; height:18px;">
					<span style="font-size:14px;">Grouper par famille</span>
				</label>
				<button id="close-collection-btn" class="close-btn">‚úï</button>
			</div>
		</div>
		<div id="collection-content" class="collection-content"></div>
	</div>
	<main id="slot-machine-wrapper">
		<div id="slot-machine"></div>
		<div id="gain-summary"></div>
	</main>
	<div id="bet-control">
		<button id="bet-minus" onclick="window.GameLogic.decreaseBet()">‚àí</button>
		<div id="bet-amount">
			<span id="bet-value">0</span>
			<span id="bet-info-icon" title="Info">‚ìò</span>
		</div>
		<button id="bet-plus" onclick="window.GameLogic.increaseBet()">+</button>
		<div id="bet-info-tooltip" style="display:none;">
			<strong>Syst√®me de Mise</strong><br>
			<small><strong>R√©sultat bas√© sur la somme des raret√©s :</strong></small><br>
			<small>Commun=0, Rare=1, √âpique=2, L√©gendaire=10, Mythique=50</small><br>
			<small>Somme &lt;1 : <span style="color:#ff3366">Perte</span> (-mise)</small><br>
			<small>Somme =1 : <span style="color:#ffaa00">Remboursement</span> (0)</small><br>
			<small>Somme &gt;1 : <span style="color:#00ff88">Gain</span> (+bonus)</small>
		</div>
	</div>
	<button id="spin-button" onclick="window.GameLogic.handleSpin()">SPIN</button>
	<button id="all-in-button" onclick="window.GameLogic.allIn()">ALL IN</button>
	</div><!-- fin game-content -->

	<!-- Scripts dans l'ordre demand√© -->
	<script type="module">
		import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
		import { getFirestore, collection, doc, getDoc, setDoc, query, where, getDocs } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

		// Configuration Firebase
		const firebaseConfig = {
			apiKey: "AIzaSyBHkZktYCmi0b5-K969AiMzCIQgh24Wk78",
			authDomain: "gambling-made.firebaseapp.com",
			projectId: "gambling-made",
			storageBucket: "gambling-made.firebasestorage.app",
			messagingSenderId: "299925832328",
			appId: "1:299925832328:web:6943a73f3ed7ef0ded553d"
		};

		const app = initializeApp(firebaseConfig);
		const db = getFirestore(app);
		window.firebaseDB = db;

		// D√©marrer la musique de fond
		const bgm = document.getElementById('bgm');
		if (bgm) {
			bgm.volume = 0.3;
			// Tenter de d√©marrer (peut √™tre bloqu√©, on r√©essayera au premier clic)
			bgm.play().catch(() => {
				// Si autoplay bloqu√©, d√©marrer au premier clic utilisateur
				const startBgm = () => {
					bgm.play().catch(()=>{});
					document.removeEventListener('click', startBgm);
				};
				document.addEventListener('click', startBgm, { once: true });
			});
		}

		// Gestion du bouton mute musique
		const musicToggle = document.getElementById('music-toggle');
		if (musicToggle && bgm) {
			musicToggle.addEventListener('click', () => {
				if (bgm.muted) {
					bgm.muted = false;
					musicToggle.textContent = 'üîä';
					musicToggle.classList.remove('muted');
				} else {
					bgm.muted = true;
					musicToggle.textContent = 'üîá';
					musicToggle.classList.add('muted');
				}
			});
		}

		// Gestion du changement de fond d'√©cran
		const storedBg = localStorage.getItem('currentBg');
		let currentBg = storedBg === null ? 0 : (parseInt(storedBg, 10) || 0);
		if (storedBg === null) {
			try { localStorage.setItem('currentBg', '0'); } catch(e) {}
		}
		const bgToggle = document.getElementById('bg-toggle');
		// D√©tecter les fonds disponibles (0 = d√©faut, puis 1.jpg, 2.jpg, etc.)
		const availableBgs = [0]; // fond 0 toujours dispo
		
		// D√©tecter les fonds disponibles sans fetch (compatible file://)
		const detectBgs = () => {
			const foundBgs = new Map();
			const detectOne = (i) => new Promise(resolve => {
				const extensions = ['jpg', 'jpeg', 'png'];
				let remaining = 1; // Only check for 'jpg'
				let resolved = false;
				const img = new Image();
				img.onload = () => {
					if (!resolved) {
						resolved = true;
						resolve({ num: i, ext: 'jpg' }); // Only resolve with 'jpg'
					}
				};
				img.onerror = () => {
					resolve(null); // Resolve as null if the image fails to load
				};
				img.src = `assets/fonds/${i}.${remaining === 1 ? 'jpg' : 'jpeg'}?t=${Date.now()}`; // Only use 'jpg'
			});
			const tasks = [];
			for (let i = 1; i <= 20; i++) tasks.push(detectOne(i));
			Promise.all(tasks).then(results => {
				results.forEach(r => { if (r && !foundBgs.has(r.num)) foundBgs.set(r.num, r.ext); });
				foundBgs.forEach((ext, num) => availableBgs.push(num));
				window.bgExtensions = foundBgs;
				console.log('Fonds disponibles:', availableBgs, 'Extensions:', Object.fromEntries(foundBgs));
				applyBackground(currentBg);
			});
		};
		
		const applyBackground = (bgIndex) => {
			console.log('Application du fond:', bgIndex);
			if (bgIndex === 0) {
				document.body.classList.remove('bg-image');
				document.body.style.backgroundImage = '';
			} else {
				const ext = window.bgExtensions?.get(bgIndex) || 'jpg';
				document.body.classList.add('bg-image');
				document.body.style.backgroundImage = `url('assets/fonds/${bgIndex}.${ext}?t=${Date.now()}')`;
				console.log('Image charg√©e:', `assets/fonds/${bgIndex}.${ext}`);
				// Fallback: remove background if the image fails to load
				const bgImg = new Image();
				bgImg.onload = () => {
					console.log('Image charg√©e:', `assets/fonds/${bgIndex}.${ext}`);
				};
				bgImg.onerror = () => {
					console.warn('Image', `assets/fonds/${bgIndex}.${ext}`, 'introuvable');
					document.body.style.backgroundImage = 'none'; // Remove background on error
				};
				bgImg.src = `assets/fonds/${bgIndex}.${ext}`;
			}
		};
		
		if (bgToggle) {
			bgToggle.addEventListener('click', () => {
				const currentIndex = availableBgs.indexOf(currentBg);
				const nextIndex = (currentIndex + 1) % availableBgs.length;
				currentBg = availableBgs[nextIndex];
				console.log('Changement de fond:', currentBg, 'Disponibles:', availableBgs);
				localStorage.setItem('currentBg', currentBg);
				applyBackground(currentBg);
			});
		}
		
		detectBgs();


		let isRegisterMode = false;
		let isSubmitting = false;

		// D√©sactiv√©: auto-connexion depuis localStorage (l'utilisateur doit se connecter manuellement)
		const AUTO_LOGIN = false;
		if (AUTO_LOGIN) {
			const currentUser = localStorage.getItem('currentUserPseudo');
			if (currentUser) {
				getDoc(doc(db, 'users', currentUser)).then(docSnap => {
					if (docSnap.exists()) {
						loadUserData(docSnap.data(), currentUser);
					} else {
						localStorage.removeItem('currentUserPseudo');
					}
				}).catch(() => localStorage.removeItem('currentUserPseudo'));
			}
		}

		// Fonction de chargement des donn√©es utilisateur
		function loadUserData(userData, pseudo) {
			window.currentUserPseudo = pseudo;
			window.userRobions = userData.robions || 0;
			window.userUnlockedCards = userData.unlockedCards || [];
			window.farmSpeedLevel = userData.farmSpeedLevel || 0;
			window.farmProductionLevel = userData.farmProductionLevel || 0;
			// farmProgress n'est plus charg√© depuis Firebase (causes glitches)
			window.userMultiplierLevel = userData.multiplierLevel || 0;
			window.userRobcoinBalance = userData.robcoinBalance || 0;
			// D√©clencher une synchronisation forc√©e au premier spin apr√®s connexion
			window.forceSyncPending = true;
			document.getElementById('auth-overlay').style.display = 'none';
			document.getElementById('game-content').style.display = 'block';
			document.getElementById('current-username').textContent = pseudo;
			if (window.initModules) window.initModules();
			if (window.initGameWithUserData) window.initGameWithUserData();
		}

		// Gestion du toggle connexion/inscription
		document.getElementById('auth-toggle-link').addEventListener('click', (e) => {
			e.preventDefault();
			isRegisterMode = !isRegisterMode;
			const overlay = document.getElementById('auth-overlay');
			if (isRegisterMode) {
				overlay.classList.add('register-mode');
				document.getElementById('auth-submit').textContent = "S'inscrire";
				document.getElementById('auth-toggle-text').textContent = 'D√©j√† un compte ?';
				document.getElementById('auth-toggle-link').textContent = 'Se connecter';
			} else {
				overlay.classList.remove('register-mode');
				document.getElementById('auth-submit').textContent = 'Se connecter';
				document.getElementById('auth-toggle-text').textContent = 'Pas de compte ?';
				document.getElementById('auth-toggle-link').textContent = 'Cr√©er un compte';
			}
			document.getElementById('auth-error').style.display = 'none';
		});

		// Gestion du formulaire connexion/inscription
		document.getElementById('auth-form').addEventListener('submit', async (e) => {
			e.preventDefault();
			if (isSubmitting) return;
			isSubmitting = true;

			const pseudo = document.getElementById('auth-pseudo').value.trim().toLowerCase();
			const password = document.getElementById('auth-password').value;
			const errorEl = document.getElementById('auth-error');

			try {
				if (isRegisterMode) {
					const userDoc = await getDoc(doc(db, 'users', pseudo));
					if (userDoc.exists()) throw new Error('Ce pseudo est d√©j√† utilis√©');
					if (pseudo.length < 3 || pseudo.length > 20) throw new Error('Le pseudo doit contenir entre 3 et 20 caract√®res');
					if (password.length < 6) throw new Error('Le mot de passe doit contenir au moins 6 caract√®res');
					
						await setDoc(doc(db, 'users', pseudo), {
					pseudo, password, robions: 0, unlockedCards: [],
					farmSpeedLevel: 0, farmProductionLevel: 0,
					multiplierLevel: 0, robcoinBalance: 0,
						createdAt: new Date().toISOString()
					});
					localStorage.setItem('currentUserPseudo', pseudo);
					loadUserData({ robions: 0, unlockedCards: [], farmSpeedLevel: 0, farmProductionLevel: 0, multiplierLevel: 0, robcoinBalance: 0 }, pseudo);
				} else {
					const userDoc = await getDoc(doc(db, 'users', pseudo));
					if (!userDoc.exists()) throw new Error('Pseudo ou mot de passe incorrect');
					const userData = userDoc.data();
					if (userData.password !== password) throw new Error('Pseudo ou mot de passe incorrect');
					
					localStorage.setItem('currentUserPseudo', pseudo);
					loadUserData(userData, pseudo);
				}
			} catch (error) {
				errorEl.textContent = error.message;
				errorEl.style.display = 'block';
			} finally {
				isSubmitting = false;
			}
		});

		// Gestion du bouton de d√©connexion
		const saveBtn = document.getElementById('save-btn');
		if (saveBtn) {
			saveBtn.addEventListener('click', async () => {
				saveBtn.disabled = true;
				saveBtn.textContent = 'üíæ Sauvegarde...';
				// S√©curit√©: si la promesse ne r√©sout pas, r√©initialiser apr√®s 10s
				const fallbackTimer = setTimeout(() => {
					saveBtn.textContent = '‚ö†Ô∏è R√©essayer';
					saveBtn.disabled = false;
				}, 10000);
				try {
					if (window.saveGameData) await window.saveGameData();
					saveBtn.textContent = '‚úÖ Sauv√©';
				} catch(e) {
					saveBtn.textContent = '‚ö†Ô∏è R√©essayer';
				} finally {
					clearTimeout(fallbackTimer);
					setTimeout(() => { saveBtn.textContent = 'üíæ Sauver'; saveBtn.disabled = false; }, 1500);
				}
			});
		}

		document.getElementById('logout-btn').addEventListener('click', () => {
			if (confirm('Voulez-vous vraiment vous d√©connecter ?')) {
				localStorage.removeItem('currentUserPseudo');
				window.currentUserPseudo = null;
				window.userRobions = null;
				window.userUnlockedCards = null;
				document.getElementById('auth-overlay').style.display = 'flex';
				document.getElementById('game-content').style.display = 'none';
				document.getElementById('current-username').textContent = '';
				// R√©initialiser le formulaire
				document.getElementById('auth-form').reset();
				document.getElementById('auth-error').style.display = 'none';
			}
		});

		// Gestion du classement
		const leaderboardBtn = document.getElementById('open-leaderboard-btn');
		const leaderboardOverlay = document.getElementById('leaderboard-overlay');
		const closeLeaderboardBtn = document.getElementById('close-leaderboard-btn');
		
		// Mode de classement: 'robions' ou 'biggestAllIn'
		let leaderboardMode = 'robions';

	leaderboardBtn.addEventListener('click', async () => {
		// Sauvegarder avant d'ouvrir pour avoir les donn√©es √† jour
		if (window.saveGameData) {
			try { await window.saveGameData(); } catch(e) {}
		}
		leaderboardOverlay.style.display = 'flex';
		loadLeaderboard();
	});
	
	async function loadLeaderboard() {
		const content = document.getElementById('leaderboard-content');
		content.innerHTML = '<div class="loading">Chargement...</div>';			try {
				const { collection, getDocs, query, orderBy, limit } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
				const usersRef = collection(db, 'users');
				
				// Changer l'ordre selon le mode
				const sortField = leaderboardMode === 'robions' ? 'robions' : 'biggestAllIn';
				const q = query(usersRef, orderBy(sortField, 'desc'), limit(50));
				const snapshot = await getDocs(q);

				if (snapshot.empty) {
					content.innerHTML = '<div class="no-data">Aucun joueur trouv√©</div>';
					return;
				}

				// Changer l'en-t√™te selon le mode
				const columnHeader = leaderboardMode === 'robions' ? 'Robions' : 'Biggest ALL IN';
				let html = `<table class="leaderboard-table ${leaderboardMode === 'biggestAllIn' ? 'risk-mode' : ''}"><thead><tr><th>#</th><th>Joueur</th><th>${columnHeader}</th><th>Cartes</th></tr></thead><tbody>`;
				let rank = 1;
				let currentUserRank = null;
				snapshot.forEach((doc) => {
					const data = doc.data();
					const isCurrentUser = doc.id === window.currentUserPseudo;
					if (isCurrentUser) currentUserRank = rank;
					let rowClass = isCurrentUser ? 'current-user' : '';
					if (rank === 1) rowClass += ' first-place';
					const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank;
					
					// Afficher selon le mode
					const displayValue = leaderboardMode === 'robions' 
						? (data.robions || 0).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ')
						: (data.biggestAllIn || 0).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
					
					// Avatar du joueur - avec gestion des noms de fichiers encod√©s
					let avatarHtml = '';
					if (data.selectedAvatar) {
						// D√©coder le nom du fichier s'il est d√©j√† encod√©
						const avatarFile = decodeURIComponent(data.selectedAvatar);
						const avatarSrc = `assets/imgV2/${encodeURIComponent(avatarFile)}`;
						avatarHtml = `<img src="${avatarSrc}" class="player-avatar" alt="Avatar" onerror="this.style.background='#000'">`;
					} else {
						avatarHtml = '<div class="player-avatar" style="background:#000;"></div>';
					}
					
					html += `<tr class="${rowClass.trim()}">
						<td>${medal}</td>
						<td><div class="player-name-cell">${avatarHtml}<span>${data.pseudo || doc.id}</span></div></td>
						<td>${displayValue}</td>
						<td>${(data.unlockedCards || []).length}</td>
					</tr>`;
					rank++;
				});
				html += '</tbody></table>';
				content.innerHTML = html;
				
				// Mettre √† jour les stats du joueur
				if (window.updatePlayerStats) {
					window.updatePlayerStats(currentUserRank);
				}
			} catch (error) {
				console.error('Erreur chargement classement:', error);
				content.innerHTML = '<div class="error">Erreur de chargement</div>';
			}
		}
		
		// Bouton pour basculer le mode de classement
		const leaderboardModeBtn = document.createElement('button');
		leaderboardModeBtn.id = 'leaderboard-mode-toggle';
		leaderboardModeBtn.className = 'leaderboard-mode-btn';
		leaderboardModeBtn.textContent = 'Biggest ALL IN';
		leaderboardModeBtn.style.cssText = 'position:absolute; top:50%; transform:translateY(-50%); right:80px; padding:6px 14px; background:rgba(255,64,64,0.15); color:#ff4040; border:1px solid rgba(255,64,64,0.4); border-radius:6px; font-size:12px; font-weight:600; cursor:pointer; transition:all 0.3s ease; backdrop-filter:blur(4px);';
		
		leaderboardModeBtn.addEventListener('click', () => {
			if (leaderboardMode === 'robions') {
				leaderboardMode = 'biggestAllIn';
				leaderboardModeBtn.textContent = 'Robions';
				leaderboardModeBtn.style.background = 'rgba(122,54,200,0.15)';
				leaderboardModeBtn.style.color = '#ad4cff';
				leaderboardModeBtn.style.borderColor = 'rgba(173,76,255,0.4)';
			} else {
				leaderboardMode = 'robions';
				leaderboardModeBtn.textContent = 'Biggest ALL IN';
				leaderboardModeBtn.style.background = 'rgba(255,64,64,0.15)';
				leaderboardModeBtn.style.color = '#ff4040';
				leaderboardModeBtn.style.borderColor = 'rgba(255,64,64,0.4)';
			}
			loadLeaderboard();
		});
		
		// Ajouter le bouton au header du leaderboard
		const leaderboardHeader = document.querySelector('.leaderboard-header');
		if (leaderboardHeader) {
			leaderboardHeader.style.position = 'relative';
			leaderboardHeader.appendChild(leaderboardModeBtn);
		}

		closeLeaderboardBtn.addEventListener('click', () => {
			leaderboardOverlay.style.display = 'none';
		});

		// Fermer en cliquant en dehors de la modal
		leaderboardOverlay.addEventListener('click', (e) => {
			if (e.target === leaderboardOverlay) {
				leaderboardOverlay.style.display = 'none';
			}
		});

		// Sidebar Toggle
		const sidebar = document.getElementById('sidebar');
		const sidebarToggle = document.getElementById('sidebar-toggle');
		
		sidebarToggle.addEventListener('click', () => {
			sidebar.classList.toggle('open');
			sidebarToggle.classList.toggle('open');
		});

		// Toggle boutique (droite)
		const shopToggle = document.getElementById('shop-toggle');
		const shopSidebar = document.getElementById('shop-sidebar');
		
		shopToggle.addEventListener('click', () => {
			shopSidebar.classList.toggle('open');
			shopToggle.classList.toggle('open');
		});

		// Fonction d'initialisation des modules
		function initModules() {
			// === FARM MODULE (SIMPLIFI√â) ===
			let farmSpeedLevel = window.farmSpeedLevel || 0;
			let farmProductionLevel = window.farmProductionLevel || 0;
			let farmInterval = null;
			let farmStartTime = 0;
			
			window.farmSpeedLevel = farmSpeedLevel;
			window.farmProductionLevel = farmProductionLevel;
			
			const FARM_BASE_TIME = 60000, FARM_MIN_TIME = 1000, FARM_MAX_PRODUCTION = 250, FARM_BASE_COST = 10;
			
			const getFarmTime = () => Math.max(FARM_MIN_TIME, FARM_BASE_TIME * Math.pow(0.95, window.farmSpeedLevel || 0));
			const getFarmProduction = () => Math.floor(Math.min(FARM_MAX_PRODUCTION, (1 + (window.farmProductionLevel || 0)) * 5));
			const getUpgradeCost = (level) => Math.floor(FARM_BASE_COST * Math.pow(1.3, level));
			const getRobions = () => window.robions || 0;
			const setRobions = (value) => { window.robions = value; };
			const isFarmActive = () => ((window.farmSpeedLevel || 0) > 0 || (window.farmProductionLevel || 0) > 0) && !!window.hasDoneFirstSpin;
			
			function showRobionsGain(amount) {
				const gainEl = document.createElement('div');
				gainEl.className = 'robions-gain';
				gainEl.textContent = `+${amount} üí∞`;
				document.body.appendChild(gainEl);
				setTimeout(() => gainEl.remove(), 2000);
			}
			
			function updateFarmDisplay() {
				const timeSeconds = (getFarmTime() / 1000).toFixed(1);
				document.getElementById('farm-production').textContent = getFarmProduction();
				document.getElementById('farm-speed').textContent = isFarmActive() ? timeSeconds : '--';
				document.getElementById('speed-cost').textContent = getUpgradeCost(window.farmSpeedLevel || 0);
				document.getElementById('production-cost').textContent = getUpgradeCost(window.farmProductionLevel || 0);
				document.getElementById('speed-level').textContent = window.farmSpeedLevel || 0;
				document.getElementById('production-level').textContent = window.farmProductionLevel || 0;
				
				const currentRobions = getRobions();
				document.getElementById('farm-upgrade-speed').disabled = currentRobions < getUpgradeCost(farmSpeedLevel) || getFarmTime() <= FARM_MIN_TIME;
				document.getElementById('farm-upgrade-production').disabled = currentRobions < getUpgradeCost(farmProductionLevel) || getFarmProduction() >= FARM_MAX_PRODUCTION;
			}
			
			window.updateFarmDisplay = updateFarmDisplay;
			
			// Fonction pour mettre √† jour les niveaux ferme depuis Firebase
			window.updateFarmLevels = function() {
				farmSpeedLevel = window.farmSpeedLevel || 0;
				farmProductionLevel = window.farmProductionLevel || 0;
				updateFarmDisplay();
				// Relancer la ferme si active
				if (isFarmActive() && !farmInterval) {
					startFarmProgress();
				}
			};
			
			function stopFarmProgress() {
				if (farmInterval) {
					clearInterval(farmInterval);
					farmInterval = null;
				}
				farmStartTime = 0;
			}
			
			function startFarmProgress() {
				stopFarmProgress();
				
				// Si la ferme est inactive, r√©initialiser l'UI et ne rien lancer
				if (!isFarmActive()) {
					const progressBar = document.getElementById('farm-progress-bar');
					const timerDisplay = document.getElementById('farm-timer');
					if (progressBar) progressBar.style.width = '0%';
					if (timerDisplay) timerDisplay.textContent = '--';
					return;
				}

				// D√©marrer un nouveau cycle √† 0
				farmStartTime = Date.now();
				const farmTime = getFarmTime();
				
				farmInterval = setInterval(() => {
					const elapsed = Date.now() - farmStartTime;
					const progress = Math.min(elapsed / farmTime, 1);
					
					const progressBar = document.getElementById('farm-progress-bar');
					const timerDisplay = document.getElementById('farm-timer');
					if (progressBar) progressBar.style.width = (progress * 100) + '%';
					const remaining = Math.max(0, farmTime - elapsed);
					if (timerDisplay) timerDisplay.textContent = Math.ceil(remaining / 1000) + 's';
					
					if (progress >= 1) {
						const production = getFarmProduction();
						setRobions(Math.floor(getRobions() + production));
						showRobionsGain(production);
						if (window.updateRobionsDisplay) window.updateRobionsDisplay();
						if (window.requestSaveGameData) window.requestSaveGameData();
						// Relancer un nouveau cycle
						startFarmProgress();
					}
				}, 100);
			}
			
			document.getElementById('farm-upgrade-speed').addEventListener('click', () => {
				const cost = getUpgradeCost(window.farmSpeedLevel || 0);
				if (getRobions() >= cost && getFarmTime() > FARM_MIN_TIME) {
					setRobions(getRobions() - cost);
					window.farmSpeedLevel = (window.farmSpeedLevel || 0) + 1;
					farmSpeedLevel = window.farmSpeedLevel;
					window.farmSpeedLevel = farmSpeedLevel;
					if (window.updateRobionsDisplay) window.updateRobionsDisplay();
					if (window.saveGameData) window.saveGameData();
					updateFarmDisplay();
					// Ne pas relancer la ferme, laisser le cycle actuel continuer
				}
			});
			
			document.getElementById('farm-upgrade-production').addEventListener('click', () => {
				const cost = getUpgradeCost(window.farmProductionLevel || 0);
				if (getRobions() >= cost && getFarmProduction() < FARM_MAX_PRODUCTION) {
					setRobions(getRobions() - cost);
					window.farmProductionLevel = (window.farmProductionLevel || 0) + 1;
					farmProductionLevel = window.farmProductionLevel;
				window.farmProductionLevel = farmProductionLevel;
				if (window.updateRobionsDisplay) window.updateRobionsDisplay();
				if (window.saveGameData) window.saveGameData();
				updateFarmDisplay();
				// Ne pas relancer la ferme, laisser le cycle actuel continuer
			}
		});			// Hook pour reset lors du rechargement utilisateur
			window.resetFarmStateOnUserReload = function() {
				stopFarmProgress();
				farmSpeedLevel = window.farmSpeedLevel || 0;
				farmProductionLevel = window.farmProductionLevel || 0;
				updateFarmDisplay();
				startFarmProgress();
			};
			
			// Fonction pour d√©marrer la ferme apr√®s le premier spin
			window.startFarmAfterFirstSpin = function() {
				updateFarmDisplay();
				if (!farmInterval) {
					startFarmProgress();
				}
			};
			
			// Initialisation au chargement (seulement affichage, pas de d√©marrage)
			setTimeout(() => {
				updateFarmDisplay();
			}, 500);
			
			// === MULTIPLIER MODULE ===
			let multiplierLevel = window.userMultiplierLevel || 0;
			let currentMultiplier = 1 + (multiplierLevel * 0.01);
			window.multiplierLevel = multiplierLevel;
			window.currentMultiplier = currentMultiplier;
			
			const MULTIPLIER_BASE_COST = 100;
			const getMultiplierCost = (level) => Math.floor(MULTIPLIER_BASE_COST * Math.pow(1.15, level));
			
			function updateMultiplierDisplay() {
				document.getElementById('current-multiplier').textContent = '√ó' + currentMultiplier.toFixed(2);
				document.getElementById('multiplier-level').textContent = multiplierLevel;
				document.getElementById('multiplier-cost').textContent = getMultiplierCost(multiplierLevel);
				document.getElementById('upgrade-multiplier').disabled = getRobions() < getMultiplierCost(multiplierLevel);
			}
			
			window.updateMultiplierDisplay = updateMultiplierDisplay;
			
			document.getElementById('upgrade-multiplier').addEventListener('click', () => {
				const cost = getMultiplierCost(multiplierLevel);
				if (getRobions() >= cost) {
					setRobions(getRobions() - cost);
					multiplierLevel++;
					currentMultiplier = 1 + (multiplierLevel * 0.01);
					window.multiplierLevel = multiplierLevel;
					window.currentMultiplier = currentMultiplier;
					if (window.updateRobionsDisplay) window.updateRobionsDisplay();
					if (window.saveGameData) window.saveGameData();
					updateMultiplierDisplay();
				}
			});
			
			updateMultiplierDisplay();
			
			// === ROBCOIN MARKET MODULE ===
			let robcoinBalance = window.userRobcoinBalance || 0;
			let robcoinPrice = 10;
			let lastPrice = robcoinPrice;
			window.robcoinBalance = robcoinBalance;
			
			function updateRobcoinPrice() {
				const change = (Math.random() - 0.5) * 0.16;
				lastPrice = robcoinPrice;
				robcoinPrice = Math.max(1, robcoinPrice * (1 + change) + (10 - robcoinPrice) * 0.05);
				updateMarketDisplay();
			}
			
			function updateMarketDisplay() {
				document.getElementById('robcoin-price').textContent = robcoinPrice.toFixed(2) + ' üí∞';
				const percentChange = ((robcoinPrice - lastPrice) / lastPrice * 100);
				const changeEl = document.getElementById('price-change');
				changeEl.textContent = (percentChange >= 0 ? '+' : '') + percentChange.toFixed(2) + '%';
				changeEl.className = 'price-change ' + (percentChange >= 0 ? 'positive' : 'negative');
				document.getElementById('robcoin-balance').textContent = robcoinBalance.toFixed(2);
				document.getElementById('holdings-value').textContent = (robcoinBalance * robcoinPrice).toFixed(0);
				
				const amount = parseFloat(document.getElementById('robcoin-amount').value) || 1;
				const buyCost = Math.ceil(amount * robcoinPrice);
				const sellGain = Math.floor(amount * robcoinPrice);
				document.getElementById('buy-cost').textContent = buyCost + ' üí∞';
				document.getElementById('sell-gain').textContent = sellGain + ' üí∞';
				document.getElementById('buy-robcoin').disabled = getRobions() < buyCost || amount <= 0;
				document.getElementById('sell-robcoin').disabled = robcoinBalance < amount || amount <= 0;
			}
			
			document.getElementById('buy-robcoin').addEventListener('click', () => {
				const amount = parseFloat(document.getElementById('robcoin-amount').value) || 1;
				const cost = Math.ceil(amount * robcoinPrice);
				if (getRobions() >= cost && amount > 0) {
					setRobions(getRobions() - cost);
					robcoinBalance += amount;
					window.robcoinBalance = robcoinBalance;
					if (window.updateRobionsDisplay) window.updateRobionsDisplay();
					if (window.saveGameData) window.saveGameData();
					updateMarketDisplay();
				}
			});
			
			document.getElementById('sell-robcoin').addEventListener('click', () => {
				const amount = parseFloat(document.getElementById('robcoin-amount').value) || 1;
				const gain = Math.floor(amount * robcoinPrice);
				if (robcoinBalance >= amount && amount > 0) {
					setRobions(getRobions() + gain);
					robcoinBalance -= amount;
					window.robcoinBalance = robcoinBalance;
					if (window.updateRobionsDisplay) window.updateRobionsDisplay();
					if (window.saveGameData) window.saveGameData();
					updateMarketDisplay();
				}
			});
			
			document.getElementById('robcoin-amount').addEventListener('input', updateMarketDisplay);
			setInterval(updateRobcoinPrice, 8000);
			updateMarketDisplay();
		}
		
		window.initModules = initModules;
	</script>

	<!-- Anti-AutoClicker System -->
	<script>
		// Temps minimum entre clics (300ms ~= 3.3 clics/sec max)
		const MIN_CLICK_INTERVAL = 300;
		let lastClickTime = 0;
		
		// Historique des clics (d√©tection pattern)
		let clickHistory = [];
		const CLICK_THRESHOLD = 6; // 6 clics
		const TIME_WINDOW = 1000; // dans 1 seconde = impossible humainement
		
		// √âtat anti-cheat global
		window.antiCheatState = {
			autoClickDetected: false
		};
		
		function isAutoClickerPattern() {
			const now = Date.now();
			clickHistory.push(now);
			// Garder seulement les clics des derni√®re seconde
			clickHistory = clickHistory.filter(t => now - t < TIME_WINDOW);
			return clickHistory.length >= CLICK_THRESHOLD;
		}
		
		function showAutoClickWarning() {
			const modal = document.createElement('div');
			modal.id = 'autoclicker-warning';
			modal.style.cssText = `
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background: linear-gradient(135deg, #ff0000, #cc0000);
				color: white;
				padding: 40px;
				border-radius: 15px;
				text-align: center;
				z-index: 10000;
				box-shadow: 0 0 40px rgba(255, 0, 0, 0.8);
				font-size: 24px;
				font-weight: bold;
				max-width: 500px;
				border: 3px solid #ff0000;
			`;
			
			modal.innerHTML = `
				<div style="margin-bottom: 20px; font-size: 28px;">‚ö†Ô∏è</div>
				<div style="margin-bottom: 30px;">Suspicion d'auto click</div>
				<button onclick="document.getElementById('autoclicker-warning').remove()" style="
					padding: 12px 30px;
					font-size: 16px;
					background: white;
					color: #cc0000;
					border: none;
					border-radius: 8px;
					cursor: pointer;
					font-weight: bold;
					transition: 0.2s;
				" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'">
					Fermer
				</button>
			`;
			
			document.body.appendChild(modal);
			window.antiCheatState.autoClickDetected = false;
		}
		
		function blockAutoClicker(e) {
			const now = Date.now();
			
			// V√©rif 1: Rate limit minimum
			if (now - lastClickTime < MIN_CLICK_INTERVAL) {
				e.preventDefault();
				return false;
			}
			
			// V√©rif 2: Pattern detection
			if (isAutoClickerPattern()) {
				e.preventDefault();
				window.antiCheatState.autoClickDetected = true;
				showAutoClickWarning();
				return false;
			}
			
			lastClickTime = now;
			return true;
		}
		
		// V√©rifier avant chaque spin si modal autoclicker est ouvert
		function canSpinWithoutAutoClickWarning() {
			return !document.getElementById('autoclicker-warning');
		}
		
		// Attacher aux boutons SPIN et ALL IN
		document.addEventListener('DOMContentLoaded', function() {
			const spinBtn = document.getElementById('spin-button');
			const allInBtn = document.getElementById('all-in-button');
			
			if (spinBtn) {
				spinBtn.addEventListener('click', function(e) {
					if (!blockAutoClicker(e)) return;
				}, { capture: true });
			}
			
			if (allInBtn) {
				allInBtn.addEventListener('click', function(e) {
					if (!blockAutoClicker(e)) return;
				}, { capture: true });
			}
		});
	</script>

	<script src="assets/js/slotmachine.js"></script>
	<script src="assets/js/game.js"></script>
	<script src="assets/js/ui.js"></script>
</body>
</html>

